// Example parameter file for B-spline registration
// C-style comments: //


// **************** Main Components **************************
// The following components should usually be left as they are:
// (Registration "MultiResolutionRegistration")
(Registration "MultiMetricMultiResolutionRegistration")

// The internal pixel type, used for internal computations
// Leave to float in general. 
// NB: this is not the type of the input images! The pixel type of the input images is automatically read from the 
// images themselves.
// This setting can be changed to "short" to save some memory in case of very large 3D images.
(FixedInternalImagePixelType "float")
(MovingInternalImagePixelType "float")
// (FixedInternalImagePixelType "short")
// (MovingInternalImagePixelType "short")

// The dimensions of the fixed and moving image
// NB: This has to be specified by the user. The dimension of the images is currently NOT read from the images.
// Also note that some other settings may have to specified for each dimension separately.
//(FixedImageDimension 2)
//(MovingImageDimension 2)
(FixedImageDimension 3)
(MovingImageDimension 3)

// Specify whether you want to take into account the so-called direction cosines of the images. Recommended: true.
// In some cases, the direction cosines of the image are corrupt, due to image format conversions for example. In
// that case, you may want to set this option to "false".
(UseDirectionCosines "true")

// Whether transforms are combined by composition or by addition.
// In generally, Compose is the best option in most cases.
(HowToCombineTransforms "Compose")


// Interpolator: Select this interpolator as follows:
(Interpolator "BSplineInterpolator")

// BSplineInterpolationOrder: the order of the B-spline polynomial.
// example: (BSplineInterpolationOrder 3 2 3)
// The default order is 1. The parameter can be specified for each resolution.
// If only given for one resolution, that value is used for the other resolutions as well.
// I recommend you set the BSplineInterpolationOrder to 1. The current setting of 3 will introduce overshoot on a binary image. The BSplineInterpolationOrder is the interpolation order used during registration. The FinalBSplineInterpolationOrder should be set to 0 for binary images. That setting does not affect the registration accuracy, just the final warping.
// (BSplineInterpolationOrder 1)													
// (BSplineInterpolationOrder 2)
(BSplineInterpolationOrder 3)

// (ResampleInterpolator "FinalBSplineInterpolator")
(ResampleInterpolator "FinalBSplineInterpolatorFloat")
//Resampler: Select this resampler as follows:
(Resampler "DefaultResampler")
//(Resampler "CUDAResampler")
// (Resampler "OpenCLResampler")
//Resampler: Enable the OpenCL resampler as follows:
// (OpenCLResamplerUseOpenCL "true")

// (FixedImagePyramid "FixedRecursiveImagePyramid")
// (MovingImagePyramid "MovingRecursiveImagePyramid")
// These may be changed to Fixed/MovingSmoothingImagePyramid.
// See the manual.
// (FixedImagePyramid "OpenCLFixedGenericImagePyramid")
// (MovingImagePyramid "OpenCLMovingGenericImagePyramid")																   
// (OpenCLFixedGenericImagePyramidUseOpenCL "true")														   
// (OpenCLMovingGenericImagePyramidUseOpenCL "true")
(FixedImagePyramid "FixedSmoothingImagePyramid")
(MovingImagePyramid "MovingSmoothingImagePyramid")


// ******************* Similarity measure *********************
// If you use a mask, this option is important. You can set it for each resolution differently.
// If you do not use a mask, the option doesn't matter.
// If the mask serves as region of interest, set it to false.
//(ErodeMask "false" "false" "false")
(ErodeMask "false")
(ErodeFixedMask "false")
(ErodeMovingMask "false")

// **************** Main Components **************************



// ******************* Optimizer ****************************
// The optimizer AdaptiveStochasticGradientDescent (ASGD) works quite ok in general. The Transform and Metric are important and need to be chosen careful for each application. See manual.
(Optimizer "AdaptiveStochasticGradientDescent")

//************ AdaptiveStochasticGradientDescent Params ****************************
//MaximumNumberOfIterations: The maximum number of iterations in each resolution.
// example: (MaximumNumberOfIterations 100 100 50)
// Default/recommended value: 500. When you are in a hurry, you may go down to 250 for example. When you have plenty of time, and want to be absolutely sure of the best results, a setting of 2000 is reasonable. In general, 500 gives satisfactory results.
// (MaximumNumberOfIterations 100 200 500 1000)
// (MaximumNumberOfIterations 50 50 50 100)
// (MaximumNumberOfIterations 250 250 500 500)
(MaximumNumberOfIterations 500 750 1000 1500)
// (MaximumNumberOfIterations 250)

// MaximumNumberOfSamplingAttempts: The maximum number of sampling attempts. Sometimes not enough corresponding samples can be drawn, upon which an exception is thrown. With this parameter it is possible to try to draw another set of samples.
// example: (MaximumNumberOfSamplingAttempts 10 15 10)
// Default value: 0, i.e. just fail immediately, for backward compatibility.
(MaximumNumberOfSamplingAttempts 100)

// AutomaticParameterEstimation: When this parameter is set to "true", many other parameters are calculated automatically: SP_a, SP_alpha, SigmoidMax, SigmoidMin, and SigmoidScale. In the elastix.log file the actually chosen values for these parameters can be found.
// example: (AutomaticParameterEstimation "true")
// Default/recommended value: "true". The parameter can be specified for each resolution, or for all resolutions at once.
(AutomaticParameterEstimation "true")

// UseAdaptiveStepSizes: When this parameter is set to "true", the adaptive step size mechanism described in the documentation of itk::AdaptiveStochasticGradientDescentOptimizer is used. The parameter can be specified for each resolution, or for all resolutions at once.
// example: (UseAdaptiveStepSizes "true")
// Default/recommend value: "true", because it makes the registration more robust. In case of using a RandomCoordinate sampler, with (UseRandomSampleRegion "true"), the adaptive step size mechanism is turned off, no matter the user setting.
(UseAdaptiveStepSizes "true")

// MaximumStepLength: Also called $\delta$. This parameter can be considered as the maximum voxel displacement between two iterations. The larger this parameter, the more aggressive the optimization. The parameter can be specified for each resolution, or for all resolutions at once.
// The step size of the optimizer, in mm. By default the voxel size is used. which usually works well. In case of unusual high-resolution images (eg histology) it is necessary to increase this value a bit, to the size of the "smallest visible structure" in the image:
// example: (MaximumStepLength 1.0)
// Default: mean voxel spacing of fixed and moving image. This seems to work well in general. This parameter only has influence when AutomaticParameterEstimation is used.
// The higher you set this, the more aggressive steps are taken.
// (MaximumStepLength 3 1 1 0.5)
(MaximumStepLength 1)
// (MaximumStepLength 3 2 1 1)
// (MinimumStepLength 0.25 0.1 0.05 0.01)						  
(MinimumStepLength 0)

// SP_a: The gain $a(k)$ at each iteration $k$ is defined by
// $a(k) = SP\_a / (SP\_A + k + 1)^{SP\_alpha}$.
// SP_a can be defined for each resolution.
// example: (SP_a 3200.0 3200.0 1600.0)
// The default value is 400.0. Tuning this variable for you specific problem is recommended. Alternatively set the AutomaticParameterEstimation to "true". In that case, you do not need to specify SP_a. SP_a has no influence when AutomaticParameterEstimation is used.

// SP_A: The gain $a(k)$ at each iteration $k$ is defined by
// $a(k) = SP\_a / (SP\_A + k + 1)^{SP\_alpha}$.
// SP_A can be defined for each resolution.
// example: (SP_A 50.0 50.0 100.0)
// The default/recommended value for this particular optimizer is 20.0.

// SP_alpha: The gain $a(k)$ at each iteration $k$ is defined by
// $a(k) = SP\_a / (SP\_A + k + 1)^{SP\_alpha}$.
// SP_alpha can be defined for each resolution.
// example: (SP_alpha 0.602 0.602 0.602)
// The default/recommended value for this particular optimizer is 1.0. Alternatively set the AutomaticParameterEstimation to "true". In that case, you do not need to specify SP_alpha. SP_alpha has no influence when AutomaticParameterEstimation is used.

// SigmoidMax: The maximum of the sigmoid function ( $f_{max}$). Must be larger than 0. The parameter can be specified for each resolution, or for all resolutions at once.
// example: (SigmoidMax 1.0)
// Default/recommended value: 1.0. This parameter has no influence when AutomaticParameterEstimation is used. In that case, always a value 1.0 is used.

// SigmoidMin: The minimum of the sigmoid function ( $f_{min}$). Must be smaller than 0. The parameter can be specified for each resolution, or for all resolutions at once.
// example: (SigmoidMin -0.8)
// Default value: -0.8. This parameter has no influence when AutomaticParameterEstimation is used. In that case, the value is automatically determined, depending on the images, metric etc.

// SigmoidScale: The scale/width of the sigmoid function ( $\omega$). The parameter can be specified for each resolution, or for all resolutions at once.
// example: (SigmoidScale 0.00001)
// Default value: 1e-8. This parameter has no influence when AutomaticParameterEstimation is used. In that case, the value is automatically determined, depending on the images, metric etc.

// SigmoidInitialTime: the initial time input for the sigmoid ( $t_0$). Must be larger than 0.0. The parameter can be specified for each resolution, or for all resolutions at once.
// example: (SigmoidInitialTime 0.0 5.0 5.0)
// Default value: 0.0. When increased, the optimization starts with smaller steps, leaving the possibility to increase the steps when necessary. If set to 0.0, the method starts with with the largest step allowed.

// NumberOfGradientMeasurements: Number of gradients N to estimate the average square magnitudes of the exact gradient and the approximation error. The parameter can be specified for each resolution, or for all resolutions at once.
// example: (NumberOfGradientMeasurements 10)
// Default value: 0, which means that the value is automatically estimated. In principle, the more the better, but the slower. In practice N=10 is usually sufficient. But the automatic estimation achieved by N=0 also works good. The parameter has only influence when AutomaticParameterEstimation is used.
// (NumberOfGradientMeasurements 10)

// NumberOfJacobianMeasurements: The number of voxels M where the Jacobian is measured, which is used to estimate the covariance matrix. The parameter can be specified for each resolution, or for all resolutions at once.
// example: (NumberOfJacobianMeasurements 5000 10000 20000)
// Default value: M = max( 1000, nrofparams ), with nrofparams the number of transform parameters. This is a rather crude rule of thumb, which seems to work in practice. In principle, the more the better, but the slower. The parameter has only influence when AutomaticParameterEstimation is used.
// (NumberOfJacobianMeasurements 5000 12500 25000 125000)
// (NumberOfJacobianMeasurements 5000 25000 75000 250000)
(NumberOfJacobianMeasurements 15000 25000 50000 100000)

// NumberOfSamplesForExactGradient: The number of image samples used to compute the 'exact' gradient. The samples are chosen on a uniform grid. The parameter can be specified for each resolution, or for all resolutions at once.
// example: (NumberOfSamplesForExactGradient 100000)
// Default/recommended: 100000. This works in general. If the image is smaller, the number of samples is automatically reduced. In principle, the more the better, but the slower. The parameter has only influence when AutomaticParameterEstimation is used.
// (NumberOfSamplesForExactGradient 250000)

// ASGDParameterEstimationMethod: The ASGD parameter estimation method used in this optimizer. The parameter can be specified for each resolution.
// example: (ASGDParameterEstimationMethod "Original")
// or (ASGDParameterEstimationMethod "DisplacementDistribution")
// Default: Original.
(ASGDParameterEstimationMethod "Original")

// MaximumDisplacementEstimationMethod: The suitable position selection method used only for displacement distribution estimation method. The parameter can be specified for each resolution.
// example: (MaximumDisplacementEstimationMethod "2sigma")
// or (MaximumDisplacementEstimationMethod "95percentile")
// Default: 2sigma.

// NoiseCompensation: Selects whether or not to use noise compensation. The parameter can be specified for each resolution, or for all resolutions at once.
// example: (NoiseCompensation "true")
// Default/recommended: true.
// ******************* Optimizer ****************************



// ******************* Transform ****************************
// Transform: Select this transform as follows:
//(Transform "BSplineTransform")
(Transform "RecursiveBSplineTransform")
// ******************* Transform Params ****************************
// BSplineTransformSplineOrder: choose a B-spline order 1,2, or 3.
// Order of B-Spline interpolation used during registration/optimisation.
// It may improve accuracy if you set this to 3. Never use 0.
// An order of 1 gives linear interpolation. This is in most applications a good choice.
// Order of B-Spline interpolation used in each resolution level:
// example: (BSplineTransformSplineOrder 3)
// Default value: 3 (cubic B-splines).
// (BSplineTransformSplineOrder 1)
// (BSplineTransformSplineOrder 2)
(BSplineTransformSplineOrder 3)

// FinalGridSpacingInVoxels: the grid spacing of the B-spline transform for each dimension.
// example: (FinalGridSpacingInVoxels 8.0 8.0 8.0)
// If only one argument is given, that factor is used for each dimension. The spacing is not in millimeters, but in "voxel size units". The default is 16.0 in every dimension.
// The control point spacing of the bspline transformation in the finest resolution level. Can be specified for each dimension differently. Unit: mm.
// This is an important option. It defines the complexity of the deformation field.
// The lower this value, the more flexible the deformation.
// Low values may improve the accuracy, but may also cause unrealistic deformations. This is a very important setting!
// We recommend tuning it for every specific application. It is difficult to come up with a good 'default' value.
// FinalGridSpacingInPhysicalUnits: the grid spacing of the B-spline transform for each dimension.
// example: (FinalGridSpacingInPhysicalUnits 8.0 8.0 8.0)
// If only one argument is given, that factor is used for each dimension. The spacing is specified in millimeters. If not specified, the FinalGridSpacingInVoxels is used, or the FinalGridSpacing, to compute a FinalGridSpacingInPhysicalUnits. If those are not specified, the default value for FinalGridSpacingInVoxels is used to compute a FinalGridSpacingInPhysicalUnits.
// Alternatively, the grid spacing can be specified in voxel units. To do that, uncomment the following line and comment/remove the FinalGridSpacingInPhysicalUnits definition.
//(FinalGridSpacingInPhysicalUnits 16)
// Final spacing of B-Spline grid (unit = size of 1 voxel)
// You can give it for each dimension differently, or for all dimensions the same.
// (FinalGridSpacingInVoxels 8.0 8.0 8.0)
// (FinalGridSpacingInVoxels 4.0 4.0 8.0)
// (FinalGridSpacingInVoxels 8)
(FinalGridSpacingInVoxels 4)
// (FinalGridSpacingInVoxels 4 4 2)

// GridSpacingSchedule: the grid spacing downsampling factors for the B-spline transform for each dimension and each resolution.
// example: (GridSpacingSchedule 4.0 4.0 2.0 2.0 1.0 1.0)
// Which is an example for a 2D image, using 3 resolutions.
// For convenience, you may also specify only one value for each resolution:
// example: (GridSpacingSchedule 4.0 2.0 1.0 ) which is equivalent to the example above.
// By default the grid spacing is halved afer every resolution, such that the final grid spacing is obtained in the last resolution level. You can also specify your own schedule, if you uncomment the following line:
//(GridSpacingSchedule 4.0 4.0 2.0 1.0)
// This setting can also be supplied per dimension.
(GridSpacingSchedule 8.0 4.0 2.0 1.0)

// PassiveEdgeWidth: the width of a band of control points at the border of the B-spline coefficient image that should remain passive during optimisation.
// Can be specified for each resolution.
// example: (PassiveEdgeWidth 0 1 2)
// The default is zero for all resolutions. A value of 4 will avoid all deformations at the edge of the image. Make sure that 2*PassiveEdgeWidth < ControlPointGridSize in each dimension.

// UseCyclicTransform: use the cyclic version of the B-spline transform which ensures that the B-spline polynomials wrap around in the slowest varying dimension. This is useful for dynamic imaging data in which the motion is assumed to be cyclic, for example in ECG-gated or respiratory gated CTA. For more information see the paper: Nonrigid registration of dynamic medical imaging data using nD+t B-splines and a groupwise optimization approach, C.T. Metz, S. Klein, M. Schaap, T. van Walsum and W.J. Niessen, Medical Image Analysis, in press.
(UseCyclicTransform "false")
// ******************* Transform ****************************

	
// ************* Metrics ****************
//(Metric "AdvancedNormalizedCorrelation")
// (Metric "AdvancedMattesMutualInformation")
// (Metric "AdvancedMattesMutualInformation" "TransformBendingEnergyPenalty")
(Metric "AdvancedMattesMutualInformation" "TransformRigidityPenalty")
(Metric0Weight 1.0)
(Metric1Weight 0.2)
// ************* Metrics Params for TransformBendingEnergyPenalty ****************
// UseOrthonormalityCondition: A flag to specify the usage of the orthonormality condition term for optimisation.
// example: (UseOrthonormalityCondition "false")
// Default is "true".
(UseOrthonormalityCondition "true")
// OrthonormalityConditionWeight: A parameter to weigh the orthonormality condition term of the rigidity term.
// example: (OrthonormalityConditionWeight 2.0)
// Default is 1.0.
(OrthonormalityConditionWeight 1.0)
// PropernessConditionWeight: A parameter to weigh the properness condition term of the rigidity term.
// example: (PropernessConditionWeight 2.0)
// Default is 1.0.
(PropernessConditionWeight 1.0)
// UseLinearityCondition: A flag to specify the usage of the linearity condition term for optimisation.
// example: (UseLinearityCondition "false")
// Default is "true".
(UseLinearityCondition "true")
// UsePropernessCondition: A flag to specify the usage of the properness condition term for optimisation.
// example: (UsePropernessCondition "false")
// Default is "true".
(UsePropernessCondition "true")
// CalculateLinearityCondition: A flag to specify if the linearity condition should still be calculated, even if it is not used for optimisation.
// example: (CalculateLinearityCondition "false")
// Default is "true".
(CalculateLinearityCondition "true")
// CalculateOrthonormalityCondition: A flag to specify if the orthonormality condition should still be calculated, even if it is not used for optimisation.
// example: (CalculateOrthonormalityCondition "false")
// Default is "true".
(CalculateOrthonormalityCondition "true")
// CalculatePropernessCondition: A flag to specify if the properness condition should still be calculated, even if it is not used for optimisation.
// example: (CalculatePropernessCondition "false")
// Default is "true".
(CalculatePropernessCondition "true")
// FixedRigidityImageName: the name of a coefficient image to specify the rigidity index of voxels in the fixed image.
// example: (FixedRigidityImageName "fixedRigidityImage.mhd")
// If not supplied the rigidity coefficient is not based on the fixed image, which is recommended.
// If neither FixedRigidityImageName nor MovingRigidityImageName are supplied, the rigidity penalty term is evaluated on the whole transform input domain.
(FixedRigidityImageName "fixedRigidityImage.mhd")
// MovingRigidityImageName: the name of a coefficient image to specify the rigidity index of voxels in the moving image.
// example: (MovingRigidityImageName "movingRigidityImage.mhd")
// If not supplied the rigidity coefficient is not based on the moving image, which is NOT recommended.
// If neither FixedRigidityImageName nor MovingRigidityImageName are supplied, the rigidity penalty term is evaluated on the whole transform input domain.
(MovingRigidityImageName "movingRigidityImage.mhd")
// DilateRigidityImages: flag to specify the dilation of the rigidity coefficient images. With this the region of rigidity can be extended to force rigidity of the inner region.
// example: (DilateRigidityImages "false" "false" "true")
// Default is "true".
(DilateRigidityImages "true" "true" "true")
// DilationRadiusMultiplier: the dilation radius is a multiplier times the grid spacing of the B-spline transform.
// example: (DilationRadiusMultiplier 1.0 1.0 2.0)
// Default is 1.0.
(DilationRadiusMultiplier 1.0 1.0 1.0)
// LinearityConditionWeight: A parameter to weigh the linearity condition term of the rigidity term.
// example: (LinearityConditionWeight 2.0)
// Default is 1.0. 
(LinearityConditionWeight 1.0)
// ************* Metrics Params for TransformBendingEnergyPenalty ****************
// ************* Metrics Params for AdvancedMattesMutualInformation ****************
// NumberOfHistogramBins: The size of the histogram. Must be given for each resolution, or for all resolutions at once.
// example: (NumberOfHistogramBins 32 32 64)
// The default is 32 for each resolution.
// Number of grey level bins in each resolution level, for the mutual information. 16 or 32 usually works fine.
// You could also employ a hierarchical strategy:
//(NumberOfHistogramBins 16 32 64)
(NumberOfHistogramBins 64)

// NumberOfFixedHistogramBins: The size of the histogram in the fixed dimension. Can be given for each resolution, or for all resolutions at once. If not given, NumberOfHistogramBins is used.
// example: (NumberOfFixedHistogramBins 32 32 64)
// The default is the value of NumberOfHistogramBins, or, if that one is also not given, 32.
(NumberOfFixedHistogramBins 64)

// NumberOfMovingHistogramBins: The size of the histogram in the fixed dimension. Can be given for each resolution, or for all resolutions at once. If not given, NumberOfHistogramBins is used.
// example: (NumberOfMovingHistogramBins 32 32 64)
// The default is the value of NumberOfHistogramBins, or, if that one is also not given, 32.
(NumberOfMovingHistogramBins 64)

// FixedKernelBSplineOrder: The B-spline order of the Parzen window, used to estimate the joint histogram. Can be given for each resolution, or for all resolutions at once.
// example: (FixedKernelBSplineOrder 0 1 1)
// The default value is 0.

// MovingKernelBSplineOrder: The B-spline order of the Parzen window, used to estimate the joint histogram. Can be given for each resolution, or for all resolutions at once.
// example: (MovingKernelBSplineOrder 3 3 3)
// The default value is 3.

// FixedLimitRangeRatio: The relative extension of the intensity range of the fixed image.
// If your fixed image has grey values from a to b and the FixedLimitRangeRatio is 0.001, the joint histogram will expect fixed image grey values from a-0.001(b-a) to b+0.001(b-a). This may be useful if you use high order B-spline interpolator for the fixed image.
// example: 
(FixedLimitRangeRatio 0.01)
// The default value is 0.01. Can be given for each resolution, or for all resolutions at once.

// MovingLimitRangeRatio: The relative extension of the intensity range of the moving image.
// If your moving image has grey values from a to b and the MovingLimitRangeRatio is 0.001, the joint histogram will expect moving image grey values from a-0.001(b-a) to b+0.001(b-a). This may be useful if you use high order B-spline interpolator for the moving image.
// example:
(MovingLimitRangeRatio 0.01)
// The default value is 0.01. Can be given for each resolution, or for all resolutions at once.

// FiniteDifferenceDerivative: Experimental feature, do not use.

// UseFastAndLowMemoryVersion: Switch between a version of mutual information that explicitely computes the derivatives of the joint histogram to each transformation parameter (false) and a version that computes the mutual information via another route (true).
// The first option allocates a large 3D matrix of size: NumberOfFixedHistogramBins * NumberOfMovingHistogramBins * number of affected B-spline parameters. This method is faster for a low number of parameters. The second method does not use this huge matrix,
// and is therefore much more memory efficient for large images and fine B-spline grids. example: (UseFastAndLowMemoryVersion "false")
// The default is "true".

// We implemented the preconditioning technique by Nicholas Tustison: "Directly Manipulated Freeform Deformations".
// It is currently only implemented for the AdvancedMattesMutualInformation metric, but it could be easily implemented
// for other metrics. The preconditioning can be selected with the option:
(UseJacobianPreconditioning "true") 
// ************* Metrics ****************



// ******************** Multiresolution **********************
// The number of resolutions. 1 Is only enough if the expected
// deformations are small. 3 or 4 mostly works fine. For large
// images and large deformations, 5 or 6 may even be useful.
(NumberOfResolutions 4)
//(NumberOfResolutions 2)

// **************** Image sampling **********************
// Number of spatial samples used to compute the mutual information (and its derivative) in each iteration.
// With an AdaptiveStochasticGradientDescent optimizer, in combination with the two options below, around 2000
// samples may already suffice.
//(NumberOfSpatialSamples 512)
//(NumberOfSpatialSamples 2048)
//(NumberOfSpatialSamples 2048)
//(NumberOfSpatialSamples 20000 30000 80000)
(NumberOfSpatialSamples 8192 16384 32768 65536)
// (NumberOfSpatialSamples 65536 65536 131072 262144)
// (NumberOfSpatialSamples 8192 8192 8192 16384)
// (NumberOfSpatialSamples 65536)
// (NumberOfSpatialSamples 8192)
(CheckNumberOfSamples "true")
(RequiredRatioOfValidSamples 0.1 0.15 0.2 0.25)
// Refresh these spatial samples in every iteration, and select them randomly. See the manual for information on other sampling strategies.
//(NewSamplesEveryIteration "true" "true" "true")
(NewSamplesEveryIteration "true")
//(ImageSampler "RandomSparseMask")
(ImageSampler "Random")
(UseRandomSampleRegion "true")




// The downsampling/blurring factors for the image pyramids.
// By default, the images are downsampled by a factor of 2
// compared to the next resolution.
// So, in 2D, with 4 resolutions, the following schedule is used:
//(ImagePyramidSchedule 8 8  4 4  2 2  1 1 )
// And in 3D:
//(ImagePyramidSchedule 8 8 8  4 4 4  2 2 2  1 1 1 )
// You can specify any schedule, for example:
//(ImagePyramidSchedule 4 4  4 3  2 1  1 1 )
//(ImagePyramidSchedule 2 2 2  1 1 1)
// Make sure that the number of elements equals the number
// of resolutions times the image dimension.
//(FixedImagePyramidSchedule  2 2 2  1 1 1 )
//(MovingImagePyramidSchedule  2 2 2  1 1 1 )
//(NumberOfResolutions 3)
//(FixedImagePyramidSchedule  2 2 2  1 1 1  0 0 0)
//(MovingImagePyramidSchedule  2 2 2  1 1 1  0 0 0)
//(NumberOfResolutions 4)
(FixedImagePyramidSchedule  8 8 8  4 4 4  2 2 2  1 1 1)
(MovingImagePyramidSchedule  8 8 8  4 4 4  2 2 2  1 1 1)




// Order of B-Spline interpolation used for applying the final deformation.
// 3 gives good accuracy; recommended in most cases.
// 1 gives worse accuracy (linear interpolation)
// 0 gives worst accuracy, but is appropriate for binary images
// (masks, segmentations); equivalent to nearest neighbor interpolation.
(FinalBSplineInterpolationOrder 1)
// (FinalBSplineInterpolationOrder 1)






//Default pixel value for pixels that come from outside the picture:
(DefaultPixelValue 0)

// Choose whether to generate the deformed moving image.
// You can save some time by setting this to false, if you are
// not interested in the final deformed moving image, but only
// want to analyze the deformation field for example.
// (WriteResultImage "true")
(WriteResultImage "false")

// The pixel type and format of the resulting deformed moving image
// Choose from (unsigned) char, (unsigned) short, float, double, etc.
// (ResultImagePixelType "short")								
// (ResultImagePixelType "double")
(ResultImagePixelType "float")
(ResultImageFormat "mhd")
(CompressResultImage "false")

(WriteTransformParametersEachIteration "false")
(WriteTransformParametersEachResolution "false")
(ShowExactMetricValue "false")


